简单队列模式
工作队列模式

大量发消息 很多消息停留在队列之中 由消费者（工作线程）处理 轮询执行

消息应答 防止消息的丢失 消费者处理完消息之后一定要告诉rabbitmq它已经处理了 然后rabbitmq可以删除了 自动应答（不好） 手动应答 
两个消费者

amqp中的消息路由 生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列

交换机类型
空串则是default
headers一般不用 与direct一样但性能极差
direct ==》routekey和bindingkey相同
fanout ==》不处理路由键 简单的将队列绑定到交换器上，像子网广播，发消息速度最快
topic ==》最灵活 通过模式匹配 比如routeKey和bindingKey usa.news usa.weather 有三组 usa news weather 将路由键和某个模式进行匹配懂吧

通过路由key给到不同的queue 灵活的发消息

rabbitmq的安装通过docker sh脚本一键安装

rabbitmq集群==》客户端在失去一个rabbitmq节点的情况下能够重新连接到集群中的任何其他节点继续生产和消费消息

目的保证消息不丢失
队列持久化 queuedeclare改为true durable
消息持久化 publish消息的时候 props消息的属性应该为持久化

轮询分发 不一定公平 如果其中一个快 来一个很慢 轮询不好
不公平分发 channel.basicQos(1) 不公平分发

预取值prefetch 比如设置成 2 5 分开分发提前设置在channel中

发布确认是解决消息不丢失的关键==》三个关键点 队列消息持久化 消费者保存在磁盘上之后 mq和生产者说一声真的保存在磁盘上了 怎么说呢 那就是发布确认了！

发布确认有三种==》单个 批量 异步

死信队列==》消息被拒绝 消息过期时间 队列达到最大长度

延迟队列==》TTL 消息延迟过期 
栗子：订单十分钟未支付则自动取消 用户注册成功之后未登录则提醒

延迟消息： 10s和40s
当前时间:Wed May 18 14:11:00 CST 2022,发送一条信息给两个ttl队列:nihao
当前时间: Wed May 18 14:11:10 CST 2022,收到死信队列的消息: 消息来自ttl为10s的队列：nihao
 当前时间: Wed May 18 14:11:40 CST 2022,收到死信队列的消息: 消息来自ttl为40s的队列：nihao

http://localhost:8080/ttl/sendMessage/nihao

延迟队列需要优化 每增加一个时间需求需要新增一个队列？不好。
新增队列 队列不设置ttl时间 ttl时间由生产者指定

还是github好用 辣鸡码云


























